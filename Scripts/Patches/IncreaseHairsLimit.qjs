/**************************************************************************\
*                                                                          *
*   Copyright (C) 2020-2024 Neo-Mind                                       *
*                                                                          *
*   This file is a part of WARP project (specific to RO clients)           *
*                                                                          *
*   WARP is free software: you can redistribute it and/or modify           *
*   it under the terms of the GNU General Public License as published by   *
*   the Free Software Foundation, either version 3 of the License, or      *
*   (at your option) any later version.                                    *
*                                                                          *
*   This program is distributed in the hope that it will be useful,        *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
*   GNU General Public License for more details.                           *
*                                                                          *
*   You should have received a copy of the GNU General Public License      *
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
*                                                                          *
*                                                                          *
|**************************************************************************|
*                                                                          *
*   Author(s)     : Neo-Mind                                               *
*   Created Date  : 2020-11-10                                             *
*   Last Modified : 2024-08-09                                             *
*                                                                          *
\**************************************************************************/

IncreaseHairsLimit = function()
{
	const DoramHairLimit = 11;
	const HumanHairLimit = 43;
	const MaxHairLimit = 999;

	//
	// Search for Hair Style limiters for Dorams and Humans on CUIResourceMgr::GetHeadName.
	//

	const DoramLimitPrefix  =
		CMP(ECX, 1)
	+   JL(WCp)
	+   CMP(ECX, DoramHairLimit)
	+   JL(WCp)
	;

	const DoramLimitSuffix =
		MOV([EDX], 10)
	+   MOV(ECX, 10)
	;

	const DoramLimitAddr = Exe.FindHex(DoramLimitPrefix + DoramLimitSuffix);
	if (DoramLimitAddr < 0)
	{
		throw Error("Doram hair-limit pattern not found on CUIResourceMgr::GetHeadName.");
	}

	const HumanLimitPrefix =
		CMP(ECX, HumanHairLimit)
	+   JL(WCp)
	;

	const HumanLimitSuffix =
		MOV([EDX], 13)
	+   MOV(ECX, 13)
	;

	const HumanLimitAddr = Exe.FindHex(HumanLimitPrefix + HumanLimitSuffix, DoramLimitAddr, DoramLimitAddr + 0x80);
	if (HumanLimitAddr < 0)
	{
		throw Error("Human hair-limit pattern not found near Doram limiter.");
	}

	//
	// Search for Hair Style vector-of-strings initialization for Male/Female Humans and Male/Female Dorams on UnknownNameFunction.
	//

	let Code =
		"50 6A 2B E8 ?? ?? ?? ?? 8B 06 C7 00 ?? ?? ?? ?? 8B 06 C7 40 04 ?? ?? ?? ?? 8B 06 C7 40 08 ?? ?? ?? ??";

	const MaleHumanHairInitializationAddr = Exe.FindHex(Code);
	if (MaleHumanHairInitializationAddr < 0)
		throw Error("Failed to find Human (Male) hairstyle vector initialization.");

	const FemaleHumanHairInitializationAddr = Exe.FindHex(Code, MaleHumanHairInitializationAddr + Code.byteCount(), MaleHumanHairInitializationAddr + 0x1F0);
	if (FemaleHumanHairInitializationAddr < 0)
	{
		throw Error("Failed to find Human (Female) hairstyle vector initialization.");
	}

	Code =
		PUSH(EAX)
	+   PUSH(DoramHairLimit)
	+   CALL(ALLWC)
	+   MOV(EAX, [ESI])
	;

	const MaleDoramHairInitializationAddr = Exe.FindHex(Code, FemaleHumanHairInitializationAddr + Code.byteCount(), FemaleHumanHairInitializationAddr + 0x1D0);
	if (MaleDoramHairInitializationAddr < 0)
	{
		throw Error("Failed to find Doram (Male) hairstyle vector initialization.");
	}

	const FemaleDoramHairInitializationAddr = Exe.FindHex(Code, MaleDoramHairInitializationAddr + Code.byteCount(), MaleDoramHairInitializationAddr + 0x90);
	if (FemaleDoramHairInitializationAddr < 0)
	{
		throw Error("Failed to find Doram (Female) hairstyle vector initialization.");
	}

	const VectorResizeCallAddr = Exe.GetTgtAddr(MaleHumanHairInitializationAddr + PUSH(EAX).byteCount() + PUSH(HumanHairLimit).byteCount() + 1);
	
	//
	// Apply all changes.
	//

	let MaxHair = Exe.GetUserInput('$MaxHair', D_Uint16, "Limit input", "Enter the maximum no of hairstyles", 43,
	{
		saveDefault: true,
		max: 1000,
	});
	
	if (MaxHair === false)
		Cancel("Limit reverted to default");

	const [HumanTarget, HumanTargetVirtual] = Exe.Allocate(this.TemplateInitializeHairStyle.byteCount() + 0x10, 0x10);
	const [DoramTarget, DoramTargetVirtual] = Exe.Allocate(this.TemplateInitializeHairStyle.byteCount() + 0x10, 0x10);

	StringAccumulator = "";
	for (let Num = DoramHairLimit; Num < MaxHair; ++Num)
	{
		StringAccumulator += ("" + Num);

		for (let NullByteNum = (8 - ("" + Num).length); 0 < NullByteNum; --NullByteNum)
		{
			StringAccumulator += "\0";
		}
	}

	const HairStyleArray = Exe.AddText(StringAccumulator)[1];
	const DoramHairStyleArray = HairStyleArray;
	const HumanHairStyleArray = HairStyleArray + (HumanHairLimit - DoramHairLimit) * 8;

	let CodeHumanInitializeHairStyleTmp = SwapFillers(this.TemplateInitializeHairStyle,
	{
		1: MaxHair,
		3: HumanHairLimit * 4,
		4: HumanHairStyleArray,
		5: MaxHair * 4,
	});

	const CodeHumanInitializeHairStyle = SetFillTargets(CodeHumanInitializeHairStyleTmp,
	{
		start: HumanTargetVirtual,
		2: VectorResizeCallAddr
	});

	let CodeDoramInitializeHairStyleTmp = SwapFillers(this.TemplateInitializeHairStyle,
	{
		1: MaxHair,
		3: DoramHairLimit * 4,
		4: DoramHairStyleArray,
		5: MaxHair * 4,
	});

	const CodeDoramInitializeHairStyle = SetFillTargets(CodeDoramInitializeHairStyleTmp,
	{
		start: DoramTargetVirtual,
		2: VectorResizeCallAddr
	});

	//
	// NOP out the limiters.
	//

	Exe.SetNOPs(DoramLimitAddr, DoramLimitPrefix.byteCount() + DoramLimitSuffix.byteCount());
	Exe.SetNOPs(HumanLimitAddr, HumanLimitPrefix.byteCount() + HumanLimitSuffix.byteCount());

	//
	// Prepare the hooking code.
	//

	Exe.SetNOPs(MaleHumanHairInitializationAddr, 8);
	Exe.SetNOPs(FemaleHumanHairInitializationAddr, 8);
	Exe.SetNOPs(MaleDoramHairInitializationAddr, 8);
	Exe.SetNOPs(FemaleDoramHairInitializationAddr, 8);

	Exe.SetCALL(MaleHumanHairInitializationAddr, HumanTargetVirtual);
	Exe.SetCALL(FemaleHumanHairInitializationAddr, HumanTargetVirtual);
	Exe.SetCALL(MaleDoramHairInitializationAddr, DoramTargetVirtual);
	Exe.SetCALL(FemaleDoramHairInitializationAddr, DoramTargetVirtual);

	Exe.SetHex(HumanTarget, CodeHumanInitializeHairStyle, CodeHumanInitializeHairStyle.byteCount());
	Exe.SetHex(DoramTarget, CodeDoramInitializeHairStyle, CodeDoramInitializeHairStyle.byteCount());

	return true;
}

IncreaseHairsLimit.validate = function()
{
	if (Exe.BuildDate > 20240000)
	{
		return true;
	}

	return false;
}

IncreaseHairsLimit.init = function()
{
	let InitializeHairStyleParts =
	[ // 0
		PUSH(EAX)
	+   PUSH(Filler(1))
	+   CALL(Filler(2))
	
	, // 1
		MOV(ECX, ESI)
	+   PUSHAD
	+   PUSH(ESI)
	+   MOV(EAX, Filler(3))
	+   MOV(ESI, Filler(4))
	
	, // 2
		MOV(EDX, [ECX])
	+   MOV([EAX, EDX], ESI)
	+   ADD(EAX, 4)
	+   ADD(ESI, 8)
	+   CMP(EAX, Filler(5))

	, // 3
		JB(Filler(6, 1))
	+   POP(ESI)
	+   POPAD
	+   RETN()
	];

	InitializeHairStyleParts[3] = SwapFillers(InitializeHairStyleParts[3], { '6, 1': -InitializeHairStyleParts[2].byteCount() });
	this.TemplateInitializeHairStyle = "";
	for (let Num = 0; Num < InitializeHairStyleParts.length; ++Num)
	{
		this.TemplateInitializeHairStyle += InitializeHairStyleParts[Num];
	}
}
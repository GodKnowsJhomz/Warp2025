/**************************************************************************\
*                                                                          *
*   Copyright (C) ?-2015 Shinryo                                           *
*   Copyright (C) 2017-2023 Andrei Karas (4144)                            *
*   Copyright (C) 2020-2023 X-EcutiOnner (xex.ecutionner@gmail.com)        *
*   Copyright (C) 2020-2023 Ai4rei/AN                                      *
*                                                                          *
*   This file is a part of WARP project (specific to RO clients)           *
*                                                                          *
*   WARP is free software: you can redistribute it and/or modify           *
*   it under the terms of the GNU General Public License as published by   *
*   the Free Software Foundation, either version 3 of the License, or      *
*   (at your option) any later version.                                    *
*                                                                          *
*   This program is distributed in the hope that it will be useful,        *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
*   GNU General Public License for more details.                           *
*                                                                          *
*   You should have received a copy of the GNU General Public License      *
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
*                                                                          *
*                                                                          *
|**************************************************************************|
*                                                                          *
*   Author(s)     : Shinryo, Andrei (4144), X-EcutiOnner, Ai4rei/AN        *
*   Created Date  : 2020-11-10                                             *
*   Last Modified : 2023-08-26                                             *
*                                                                          *
\**************************************************************************/

// TODO - Provide option to completely ignore or Sent to OutputDebugStringA function for all the patches.

///
/// \brief Modify ErrorMsg function to send the error message using OutputDebugStringA instead of showing the MessageBox
///
IgnoreRsrcErr = function(_)
{
	$$(_, 1.1, `Find the common error string`)
	let addr = Exe.FindText("Failed to load Winsock library!");
	if (addr < 0)
		throw Error("Winsock error string missing");

	$$(_, 1.2, `Find where it is PUSHed`)
	let code =
		PUSH(addr)  //push offset "Failed to load Winsock library!"
	+	CALL()      //call ErrorMsg
	;
	addr = Exe.FindHex(code);

	if (addr < 0)
		throw Error("Winsock error string not used");

	$$(_, 1.3, `Go inside the ErrorMsg function`)
	addr = Exe.GetTgtAddr(addr + 6, PHYSICAL);

	$$(_, 2.1, `Find the GDIFlip CALL at the beginning of the function`)
	addr = Exe.FindHex( CALL(NEG3WC), addr, addr + 10);
	if (addr < 0)
		throw Error("GDIFlip CALL missing");

	$$(_, 2.2, `Set the address to after the call`)
	addr += 5;

	$$(_, 2.3, `Prep code to replace with (for calling OutputDebugStringA & stack restoration)`)
	ROC.findImports();

	code =
		PUSH([ROC.StkReg, ROC.HasFP ? 8 : 4]) //push dword ptr [ARG.1] ; where ARG.1 = ebp+8 with fp and esp+4 without fp.
	+	CALL([ROC.OutDbgStrA])                //call dword ptr [&KERNEL32.OutputDebugStringA]
	+	XOR(EAX, EAX)                         //xor eax, eax
	+  	(ROC.HasFP
	?
		POP(EBP)                              //pop ebp ; if EBP was PUSHed before
	:
		''
	)
	+	RETN()                                //retn
	;
	Exe.SetHex(addr, code);

	return true;
};

///
/// \brief Change the code used to show message box when CFile::Open result status is false (inside CPaletteRes::Load function)
///        into reporting with OutputDebugStringA instead.
///
IgnorePalErr = function(_)
{
	// Helper: convert 32-bit value to little-endian hex (for SSE imm32 patterns)
	function ToHexLE32(val) {
		let s = "";
		for (let i = 0; i < 4; i++) {
			const b = (val >>> (i * 8)) & 0xFF;
			s += ("0" + b.toString(16)).slice(-2).toUpperCase();
			if (i < 3) s += " ";
		}
		return s;
	}

	$$(_, 1.1, "Find message text address");
	const msgAddr = Exe.FindText("CPaletteRes :: Cannot find File : ");
	if (msgAddr < 0)
		throw Error("CPaletteRes string not found");

	$$(_, 1.2, "Find a nearby reference to the message (PUSH/MOV/SSE)");
	let ref = -1;

	// A) PUSH imm32
	ref = Exe.FindHex(PUSH(msgAddr));

	// B) MOV r32, imm32
	if (ref < 0) {
		const regs = [EAX, ECX, EDX, EBX, ESI, EDI];
		for (let r of regs) {
			ref = Exe.FindHex(MOV(r, msgAddr));
			if (ref >= 0) break;
		}
	}

	// C) PUSH imm32 + (LEA|MOV â€¦)
	if (ref < 0) {
		let t = Exe.FindHex(PUSH(msgAddr) + LEA());
		if (t < 0) t = Exe.FindHex(PUSH(msgAddr) + MOV([]));
		if (t >= 0) ref = t;
	}

	// D) MOV EDI, imm32
	if (ref < 0)
		ref = Exe.FindHex(MOV(EDI, msgAddr));

	// E) SSE: movups xmm0, [imm32]  (0F 10 05 <imm32-LE>)
	if (ref < 0) {
		const imm = ToHexLE32(msgAddr);
		ref = Exe.FindHex("0F 10 05 " + imm);
	}

	if (ref < 0)
		throw Error("CPaletteRes reference not found");

	$$(_, 2.1, "Flip conditional jump near 'test *, *' around the reference");

	// 1) test al, al ; jnz rel32  => force always jump
	let at = Exe.FindHex("84 C0 0F 85 ?? ?? ?? ??", ref - 0x300, ref + 0x80);
	if (at >= 0) {
		// 0F 85 -> 90 E9
		Exe.SetHex(at + 2, "90 E9");
		return true;
	}

	// 2) test eax, eax ; jnz rel32
	at = Exe.FindHex("85 C0 0F 85 ?? ?? ?? ??", ref - 0x300, ref + 0x80);
	if (at >= 0) {
		Exe.SetHex(at + 2, "90 E9");
		return true;
	}

	// 3) test al, al ; jnz short
	at = Exe.FindHex("84 C0 75 ??", ref - 0x200, ref + 0x40);
	if (at >= 0) {
		// 75 -> EB (short JMP)
		Exe.SetHex(at + 2, "EB");
		return true;
	}

	// 4) test eax, eax ; jnz short
	at = Exe.FindHex("85 C0 75 ??", ref - 0x200, ref + 0x40);
	if (at >= 0) {
		Exe.SetHex(at + 2, "EB");
		return true;
	}

	throw Error("Conditional jump pattern not found around reference");
};

// (optional) expose only for modern clients; adjust if you want wider support
IgnorePalErr.validate = () => Exe.BuildDate >= 20170000;

///
/// \brief Modify LuaErrorMsg function to send the error message to OutputDebugStringA instead of showing it with MessageBoxA
///
IgnoreLuaErr = function(_)
{
	$$(_, 1.1, `Ensure "MessageBoxA" has been imported`)
	ROC.findImports();

	$$(_, 1.2, `Find the LuaErrorMsg function code`)
	const cmn = LEA(R32, [ROC.StkReg, ROC.HasFP ? NEG2WC : WCp]); //lea regB, [LOCAL.x] ; where the displacement is -ve for EBP but +ve for ESP.

	let parts =
	[
		Exe.Version === 6
	?
			CALL(ALLWC)          //call std::string::sprintf
		+	MOV(R32, [EBP, WCp]) //mov regA, dword ptr [ebp+x]
		+	ADD(ESP, WCp)        //add esp, imm8A ; usually 0Ch
	:
			CALL([POS3WC])       //call dword ptr [<&MSVCR110.vsprintf>] ; can also be different print function
		+	ADD(ESP, WCp)        //add esp, 0Ch / 1Ch

	,//1
			''

	,//2
			cmn                  //lea regB, [LOCAL.x]

	,//3
			PUSH_0               //push 0
		+	PUSH_R               //push regA

	,//4
			PUSH_R               //push regB
		+	PUSH_0               //push 0
		+	CALL([ROC.MsgBoxA])  //call dword ptr [<&USER32.MessageBoxA>]
	];

	let addr = Exe.FindHex(parts);
	if (addr < 0)
	{
		[parts[1], parts[3]] = [parts[3], parts[1]];

		addr = Exe.FindHex(parts);
	}

	if (addr < 0)
		throw Error("LuaErrorMsg function missing");

	$$(_, 2.1, `Check for the OutputDebugStringA function address`)
	if (ROC.OutDbgStrA < 0)
		throw Error("'OutputDebugStringA' function missing");

	$$(_, 2.2, `Calculate the addresses for each part`)
	const offsets = MapAddrs(addr, parts);

	$$(_, 2.3, `NOP out any code in 2nd part`)
	if (!parts[1].isEmpty())
		Exe.SetNOPs(offsets[1], offsets[2] - offsets[1]);

	$$(_, 2.4, `NOP out any code in 4th part`)
	if (!parts[3].isEmpty())
		Exe.SetNOPs(offsets[3], offsets[4] - offsets[3]);

	$$(_, 2.5, `Change the MessageBoxA CALL to OutputDebugStringA CALL followed by xor eax, eax`)
	Exe.SetHex( offsets[4] + 1,
		CALL([ROC.OutDbgStrA])  //call dword ptr [&KERNEL32.OutputDebugStringA]
	+	XOR(EAX, EAX)           //xor eax, eax
	);

	return true;
};

///
/// \brief Disable for unsupported clients - Only 2010+ have Lua
///
IgnoreLuaErr.validate = IsPost2010;

///
/// \brief Modify QuestErrorMsg function to send the error message to OutputDebugStringA instead of showing it with MessageBoxA
///
IgnoreQuestErr = function(_)
{
	$$(_, 1.1, `Ensure "MessageBoxA" has been imported`)
	ROC.findImports();

	$$(_, 1.2, `Find the MessageBoxA CALL inside QuestErrorMsg function`)
	const prefix =
		PUSH(this.FmtAddr)      //push offset "Not found Quest Info = %lu"
	+	PUSH_EAX                //push eax
	+	CALL(ALLWC)             //call std::string::sprintf
	+	ADD(ESP, 0xC)           //add esp, 0Ch
	+	MOV([EBP, WC], 1)       //mov dword ptr [LOCAL.x], 1
	+	CMP([EAX, 0x14], 0x10)  //cmp dword ptr [eax+14h], 10h
	+	JB(2)                   //jb short _skip ; skips the MOV below
	+	MOV(EAX, [EAX])         //mov eax, dword ptr [eax]
	;

	const suffix =
		PUSH_0                  //push 0
	+	PUSH(POS4WC)            //push offset "Error"
	+	PUSH_EAX                //push eax
	+	PUSH([POS4WC])          //push dword ptr [g_hMainWnd]
	+	CALL([ROC.MsgBoxA])     //call dword ptr [<&USER32.MessageBoxA>]
	;

	let addr = Exe.FindHex(prefix + suffix);
	if (addr < 0)
		throw Error("QuestErrorMsg not found");

	$$(_, 2.1, `Set addr to location after prefix`)
	addr += prefix.byteCount();

	$$(_, 2.2, `Check the OutputDebugStringA function address`)
	if (ROC.OutDbgStrA < 0)
		throw Error("'OutputDebugStringA' function missing");

	$$(_, 2.3, `Prepare the replacement code (CALLs OutputDebugStringA instead)`)
	let code =
		PUSH_EAX               //push eax
	+	CALL([ROC.OutDbgStrA]) //call dword ptr [&KERNEL32.OutputDebugStringA]
	+	XOR(EAX, EAX)          //xor eax, eax
	;
	code += NOPs(suffix.byteCount() - code.byteCount());

	$$(_, 2.4, `Now replace it`)
	Exe.SetHex(addr, code);

	return true;
};

///
/// \brief Disable for unsupported clients - Need that format string present
///
IgnoreQuestErr.validate = function()
{
	this.FmtAddr = Exe.FindText("Not found Quest Info = %lu");
	return (this.FmtAddr > 0);
};

///
/// \brief Modify EntryQueueErrorMsg function to send the error message to OutputDebugStringA
///
IgnoreEntryQueueErr = function(_)
{
	$$(_, 1.1, `Find the location where the file is accessed`)
	const parts =
	[
		PUSH(this.BexAddr)  //push offset "Data\Table\EntryQueue.bex"
	+	CALL([POS3WC])      //call dword ptr [&CreateFileA]
	+	MOV(R32, EAX)       //mov regA, eax
	+	CMP(R32, -1)        //cmp regA, -1
	+	JNZ(WCp)            //jne short _skip

	,//1
		PUSH(0x30)          //push 30h ; '0'
	+	PUSH(POS3WC)        //push offset "Load Failed"
	+	PUSH(this.BexAddr)  //push offset "Data\Table\EntryQueue.bex"

	,//2
		Exe.Version > 10
	?
		PUSH_0              //push 0
	:
		PUSH_R              //push regB

	,//3
		CALL([POS3WC])      //call dword ptr [<&USER32.MessageBoxA>]
	];

	let addr = Exe.FindHex(parts);
	if (addr < 0)
		throw Error("Pattern not found");

	$$(_, 1.2, `Calculate the positional addresses`)
	const addrs = MapAddrs(addr, parts);

	$$(_, 1.3, `Add the error string`)
	const [, strAddr] = Exe.AddText("EntryQueue Loading Failed");

	$$(_, 2.1, `Get the OutputDebugStringA function address`)
	ROC.findImports();

	$$(_, 2.2, `Prepare the replacement code (CALLs OutputDebugStringA instead)`)
	let code =
		PUSH(strAddr)           //push offset "EntryQueue Loading Failed"
	+	CALL([ROC.OutDbgStrA])  //call dword ptr [&KERNEL32.OutputDebugStringA]
	+	XOR(EAX, EAX)           //xor eax, eax
	;
	code += NOPs( addrs.last() - (addrs[1] + code.byteCount()) );

	$$(_, 2.3, `Now replace it`)
	Exe.SetHex(addrs[1], code);

	return true;
};

///
/// \brief Disable for unsupported clients - Need the file name
///
IgnoreEntryQueueErr.validate = function()
{
	this.BexAddr = Exe.FindText("Data\\Table\\EntryQueue.bex");
	return (this.BexAddr > 0);
};
